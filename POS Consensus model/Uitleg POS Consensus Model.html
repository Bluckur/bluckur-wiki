<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url('https://themes.googleusercontent.com/fonts/css?kit=cGvuclDC_Z1vE_cnVEU6AZE65dyIhfXXg-cf5jhD1wfM_ZCN6WR5CBDkko84S-AE');ol.lst-kix_m8573t54ed9m-3{list-style-type:none}ol.lst-kix_m8573t54ed9m-4{list-style-type:none}ol.lst-kix_m8573t54ed9m-5{list-style-type:none}ol.lst-kix_m8573t54ed9m-6{list-style-type:none}ol.lst-kix_m8573t54ed9m-0{list-style-type:none}ol.lst-kix_m8573t54ed9m-1{list-style-type:none}ol.lst-kix_m8573t54ed9m-2{list-style-type:none}ol.lst-kix_m8573t54ed9m-2.start{counter-reset:lst-ctn-kix_m8573t54ed9m-2 0}.lst-kix_m8573t54ed9m-1>li{counter-increment:lst-ctn-kix_m8573t54ed9m-1}.lst-kix_m8573t54ed9m-2>li{counter-increment:lst-ctn-kix_m8573t54ed9m-2}.lst-kix_m8573t54ed9m-8>li{counter-increment:lst-ctn-kix_m8573t54ed9m-8}ol.lst-kix_2gqi8pmb35nb-8.start{counter-reset:lst-ctn-kix_2gqi8pmb35nb-8 0}ol.lst-kix_2gqi8pmb35nb-0.start{counter-reset:lst-ctn-kix_2gqi8pmb35nb-0 0}.lst-kix_2gqi8pmb35nb-4>li{counter-increment:lst-ctn-kix_2gqi8pmb35nb-4}ol.lst-kix_2gqi8pmb35nb-5.start{counter-reset:lst-ctn-kix_2gqi8pmb35nb-5 0}.lst-kix_m8573t54ed9m-0>li{counter-increment:lst-ctn-kix_m8573t54ed9m-0}.lst-kix_m8573t54ed9m-6>li{counter-increment:lst-ctn-kix_m8573t54ed9m-6}.lst-kix_m8573t54ed9m-3>li{counter-increment:lst-ctn-kix_m8573t54ed9m-3}.lst-kix_2gqi8pmb35nb-5>li{counter-increment:lst-ctn-kix_2gqi8pmb35nb-5}.lst-kix_m8573t54ed9m-7>li:before{content:"" counter(lst-ctn-kix_m8573t54ed9m-7,lower-latin) ". "}.lst-kix_m8573t54ed9m-8>li:before{content:"" counter(lst-ctn-kix_m8573t54ed9m-8,lower-roman) ". "}.lst-kix_2gqi8pmb35nb-2>li{counter-increment:lst-ctn-kix_2gqi8pmb35nb-2}ol.lst-kix_m8573t54ed9m-6.start{counter-reset:lst-ctn-kix_m8573t54ed9m-6 0}.lst-kix_2gqi8pmb35nb-8>li{counter-increment:lst-ctn-kix_2gqi8pmb35nb-8}.lst-kix_m8573t54ed9m-5>li:before{content:"" counter(lst-ctn-kix_m8573t54ed9m-5,lower-roman) ". "}.lst-kix_m8573t54ed9m-6>li:before{content:"" counter(lst-ctn-kix_m8573t54ed9m-6,decimal) ". "}ol.lst-kix_m8573t54ed9m-0.start{counter-reset:lst-ctn-kix_m8573t54ed9m-0 0}ol.lst-kix_m8573t54ed9m-7{list-style-type:none}ol.lst-kix_m8573t54ed9m-3.start{counter-reset:lst-ctn-kix_m8573t54ed9m-3 0}ol.lst-kix_m8573t54ed9m-8{list-style-type:none}.lst-kix_m8573t54ed9m-0>li:before{content:"" counter(lst-ctn-kix_m8573t54ed9m-0,decimal) ". "}ol.lst-kix_2gqi8pmb35nb-0{list-style-type:none}ol.lst-kix_m8573t54ed9m-4.start{counter-reset:lst-ctn-kix_m8573t54ed9m-4 0}ol.lst-kix_2gqi8pmb35nb-1{list-style-type:none}.lst-kix_2gqi8pmb35nb-2>li:before{content:"" counter(lst-ctn-kix_2gqi8pmb35nb-2,lower-roman) ". "}ol.lst-kix_2gqi8pmb35nb-2{list-style-type:none}.lst-kix_2gqi8pmb35nb-4>li:before{content:"" counter(lst-ctn-kix_2gqi8pmb35nb-4,lower-latin) ". "}ol.lst-kix_2gqi8pmb35nb-3{list-style-type:none}.lst-kix_m8573t54ed9m-1>li:before{content:"" counter(lst-ctn-kix_m8573t54ed9m-1,lower-latin) ". "}.lst-kix_m8573t54ed9m-2>li:before{content:"" counter(lst-ctn-kix_m8573t54ed9m-2,lower-roman) ". "}ol.lst-kix_2gqi8pmb35nb-4{list-style-type:none}ol.lst-kix_2gqi8pmb35nb-5{list-style-type:none}.lst-kix_2gqi8pmb35nb-3>li:before{content:"" counter(lst-ctn-kix_2gqi8pmb35nb-3,decimal) ". "}ol.lst-kix_2gqi8pmb35nb-6{list-style-type:none}.lst-kix_2gqi8pmb35nb-1>li{counter-increment:lst-ctn-kix_2gqi8pmb35nb-1}.lst-kix_m8573t54ed9m-3>li:before{content:"" counter(lst-ctn-kix_m8573t54ed9m-3,decimal) ". "}.lst-kix_m8573t54ed9m-4>li:before{content:"" counter(lst-ctn-kix_m8573t54ed9m-4,lower-latin) ". "}ol.lst-kix_2gqi8pmb35nb-6.start{counter-reset:lst-ctn-kix_2gqi8pmb35nb-6 0}.lst-kix_2gqi8pmb35nb-6>li:before{content:"" counter(lst-ctn-kix_2gqi8pmb35nb-6,decimal) ". "}ol.lst-kix_2gqi8pmb35nb-2.start{counter-reset:lst-ctn-kix_2gqi8pmb35nb-2 0}.lst-kix_2gqi8pmb35nb-5>li:before{content:"" counter(lst-ctn-kix_2gqi8pmb35nb-5,lower-roman) ". "}.lst-kix_m8573t54ed9m-5>li{counter-increment:lst-ctn-kix_m8573t54ed9m-5}ol.lst-kix_m8573t54ed9m-7.start{counter-reset:lst-ctn-kix_m8573t54ed9m-7 0}ol.lst-kix_2gqi8pmb35nb-3.start{counter-reset:lst-ctn-kix_2gqi8pmb35nb-3 0}.lst-kix_2gqi8pmb35nb-7>li:before{content:"" counter(lst-ctn-kix_2gqi8pmb35nb-7,lower-latin) ". "}ol.lst-kix_2gqi8pmb35nb-7{list-style-type:none}ol.lst-kix_2gqi8pmb35nb-8{list-style-type:none}.lst-kix_2gqi8pmb35nb-8>li:before{content:"" counter(lst-ctn-kix_2gqi8pmb35nb-8,lower-roman) ". "}.lst-kix_2gqi8pmb35nb-7>li{counter-increment:lst-ctn-kix_2gqi8pmb35nb-7}.lst-kix_2gqi8pmb35nb-0>li{counter-increment:lst-ctn-kix_2gqi8pmb35nb-0}ol.lst-kix_m8573t54ed9m-5.start{counter-reset:lst-ctn-kix_m8573t54ed9m-5 0}.lst-kix_2gqi8pmb35nb-6>li{counter-increment:lst-ctn-kix_2gqi8pmb35nb-6}.lst-kix_2gqi8pmb35nb-3>li{counter-increment:lst-ctn-kix_2gqi8pmb35nb-3}ol.lst-kix_m8573t54ed9m-1.start{counter-reset:lst-ctn-kix_m8573t54ed9m-1 0}ol.lst-kix_2gqi8pmb35nb-1.start{counter-reset:lst-ctn-kix_2gqi8pmb35nb-1 0}ol.lst-kix_2gqi8pmb35nb-7.start{counter-reset:lst-ctn-kix_2gqi8pmb35nb-7 0}ol.lst-kix_m8573t54ed9m-8.start{counter-reset:lst-ctn-kix_m8573t54ed9m-8 0}.lst-kix_m8573t54ed9m-4>li{counter-increment:lst-ctn-kix_m8573t54ed9m-4}.lst-kix_2gqi8pmb35nb-0>li:before{content:"" counter(lst-ctn-kix_2gqi8pmb35nb-0,decimal) ". "}.lst-kix_m8573t54ed9m-7>li{counter-increment:lst-ctn-kix_m8573t54ed9m-7}ol.lst-kix_2gqi8pmb35nb-4.start{counter-reset:lst-ctn-kix_2gqi8pmb35nb-4 0}.lst-kix_2gqi8pmb35nb-1>li:before{content:"" counter(lst-ctn-kix_2gqi8pmb35nb-1,lower-latin) ". "}ol{margin:0;padding:0}table td,table th{padding:0}.c19{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;background-color:#f8f8f8;border-left-style:solid;border-bottom-width:0pt;width:451.4pt;border-top-color:#000000;border-bottom-style:solid}.c14{background-color:#2b2b2b;color:#a9b7c6;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:"Courier New";font-style:normal}.c20{background-color:#2b2b2b;color:#cc7832;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:"Raleway";font-style:normal}.c15{background-color:#2b2b2b;color:#cc7832;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:"Courier New";font-style:normal}.c2{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left;height:11pt}.c7{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c8{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:16pt;font-family:"Raleway";font-style:normal}.c10{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:"Arial";font-style:normal}.c16{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:20pt;font-family:"Raleway";font-style:normal}.c6{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c21{padding-top:20pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;text-align:left}.c1{background-color:#f8f8f8;font-size:9pt;font-family:"Consolas";color:#333333;font-weight:400}.c5{background-color:#f8f8f8;font-size:9pt;font-family:"Consolas";color:#333333;font-weight:700}.c3{background-color:#f8f8f8;font-size:9pt;font-family:"Consolas";color:#dd1144;font-weight:400}.c4{background-color:#f8f8f8;font-size:9pt;font-family:"Consolas";color:#008080;font-weight:400}.c0{padding-top:18pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;text-align:left}.c11{background-color:#f8f8f8;font-size:9pt;font-family:"Consolas";color:#990000;font-weight:700}.c17{border-spacing:0;border-collapse:collapse;margin-right:auto}.c12{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c18{background-color:#ffffff;max-width:451.4pt;padding:72pt 72pt 72pt 72pt}.c22{font-weight:400;font-family:"Raleway"}.c13{height:11pt}.c9{height:0pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c18"><h1 class="c21" id="h.lmzfinapzlzo"><span class="c16">PROOF OF STAKE </span></h1><p class="c2"><span class="c7"></span></p><p class="c6"><span class="c7">Uitleg van het proof of stake model gemaakt door S6 van periode: Februari t/m Juni 2018. Geschreven door Merik Westerveld - S64. </span></p><p class="c2"><span class="c7"></span></p><p class="c6"><span class="c7">De volgende stappen leggen in volgorde uit hoe het proof of stake consensus model in elkaar zit en werkt. De volgende stappen slaan we in detail over: Genereren / inloggen van een wallet - tijd gelijk stellen met het netwerk - binnenhalen van de up-to-date ledger tot wanneer de wallet een volledig geupdate node is. Vanaf dit moment gaat het proof of stake model in werking en moet het de volgende stappen uitvoeren.</span></p><p class="c2"><span class="c7"></span></p><h2 class="c0" id="h.hdfzj4qzcfsh"><span class="c22">1. Maak een nieuwe transactie</span></h2><a id="t.294e0811c1b8a2903002e85d10c8a869e91240e7"></a><a id="t.0"></a><table class="c17"><tbody><tr class="c9"><td class="c19" colspan="1" rowspan="1"><p class="c12"><span class="c1">Transaction transaction = </span><span class="c5">new</span><span class="c1">&nbsp;Transaction();<br>SharedMessage&lt;Transaction&gt; newTransactionMessage = </span><span class="c5">null</span><span class="c1">;<br><br></span><span class="c5">if</span><span class="c1">(input.substring(</span><span class="c4">0</span><span class="c1">, </span><span class="c4">1</span><span class="c1">).toLowerCase().equals(</span><span class="c3">&quot;c&quot;</span><span class="c1">)) {<br> &nbsp; transaction = </span><span class="c5">new</span><span class="c1">&nbsp;CoinTransaction(wallet.getPublicKey(),<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wallet.getPrivateKey(),<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HashUtil.decodePublicKey(publicKey),<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; amount);<br> &nbsp; newTransactionMessage = </span><span class="c5">new</span><span class="c1">&nbsp;SharedMessage(transaction, Global.getMyIp(), MessageType.NEW_COIN_TRANSACTION);<br>} </span><span class="c5">else</span><span class="c1">&nbsp;</span><span class="c5">if</span><span class="c1">(input.substring(</span><span class="c4">0</span><span class="c1">, </span><span class="c4">1</span><span class="c1">).toLowerCase().equals(</span><span class="c3">&quot;s&quot;</span><span class="c1">)){<br> &nbsp; transaction = </span><span class="c5">new</span><span class="c1">&nbsp;StakeTransaction(wallet.getPublicKey(),<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wallet.getPrivateKey(),<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HashUtil.decodePublicKey(publicKey),<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; amount);<br> &nbsp; newTransactionMessage = </span><span class="c5">new</span><span class="c1">&nbsp;SharedMessage(transaction, Global.getMyIp(), MessageType.NEW_STAKE_TRANSACTION);<br>}<br><br>WebSocketServer.handler.addToReceivedMessage(newTransactionMessage);<br>WebSocketClientWrapper.getWrapper().sendMessage(newTransactionMessage);</span></p></td></tr></tbody></table><p class="c12 c13"><span class="c7"></span></p><p class="c12"><span class="c7">Er wordt gekeken of er in de console een nieuwe coin of nieuwe stake transactie is gemaakt. Op basis hiervan wordt er een nieuwe transactie gemaakt met de huidige wallet (deze transactie wordt dus ook gesigned met de private key van de huidige wallet). Vervolgens wordt de gemaakte transactie verstuurd naar de peers (P2P netwerk wordt hier in gang gebracht). </span></p><p class="c12 c13"><span class="c7"></span></p><h2 class="c0" id="h.3z2ydabl7spr"><span class="c8">2. Ontvangen van de gemaakte transactie </span></h2><a id="t.64b045294e43fab33a169fd2e349957a766cfcca"></a><a id="t.1"></a><table class="c17"><tbody><tr class="c9"><td class="c19" colspan="1" rowspan="1"><p class="c12"><span class="c1">TemporaryStorage.getInstance().addPendingCoinTransaction((CoinTransaction) message.getContent());<br>System.out.println(</span><span class="c3">&quot;[INFO] Received new coin transaction: &quot;</span><span class="c1">&nbsp;+ message.getContent().toString());<br></span><span class="c5">if</span><span class="c1">(handler.shouldSendMessage(message)) {<br> &nbsp; handler.forwardToPeers(message);<br>}</span></p></td></tr></tbody></table><p class="c12 c13"><span class="c7"></span></p><p class="c12"><span class="c7">De ontvangers ontvangen de nieuwe transactie en zetten deze transactie in de pendingCoinTransaction lijst. Deze pendingCoinTransaction lijst in de temporary storage singleton wordt later gebruikt bij het genereren van een nieuw block.</span></p><p class="c12 c13"><span class="c7"></span></p><h2 class="c0" id="h.f6zs0rbzyhku"><span class="c8">3. Nieuw block maken</span></h2><a id="t.92e7497b612a7246731181439265852d2afc55bb"></a><a id="t.2"></a><table class="c17"><tbody><tr class="c9"><td class="c19" colspan="1" rowspan="1"><p class="c12"><span class="c1">Thread createBlockThread = </span><span class="c5">new</span><span class="c1">&nbsp;Thread(() -&gt; {<br> &nbsp; String lastBlockHash = GlobalState.getInstance().getLastBlockHash();<br> &nbsp; Block proposedBlock;<br> &nbsp; </span><span class="c5">if</span><span class="c1">(!lastBlockHash.trim().equals(</span><span class="c3">&quot;&quot;</span><span class="c1">)){<br> &nbsp; &nbsp; &nbsp; proposedBlock = </span><span class="c5">new</span><span class="c1">&nbsp;Block(lastBlockHash, validator, TemporaryStorage.getInstance().getPendingCoinTransactions(),<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TemporaryStorage.getInstance().getPendingStakeTransactions());<br> &nbsp; } </span><span class="c5">else</span><span class="c1">&nbsp;{<br> &nbsp; &nbsp; &nbsp; proposedBlock = </span><span class="c5">new</span><span class="c1">&nbsp;Block(</span><span class="c3">&quot;&quot;</span><span class="c1">, validator, TemporaryStorage.getInstance().getPendingCoinTransactions(),<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TemporaryStorage.getInstance().getPendingStakeTransactions());<br> &nbsp; }<br><br> &nbsp; TemporaryStorage.getInstance().addProposedBlock(proposedBlock);<br><br> &nbsp; SharedMessage sendMessage = </span><span class="c5">new</span><span class="c1">&nbsp;SharedMessage(proposedBlock, Global.getMyIp(), MessageType.NEW_BLOCK);<br> &nbsp; WebSocketServer.handler.addToReceivedMessage(sendMessage);<br> &nbsp; WebSocketClientWrapper.getWrapper().sendMessage(sendMessage);<br><br> &nbsp; Timer timer = </span><span class="c5">new</span><span class="c1">&nbsp;Timer();<br> &nbsp; timer.schedule(</span><span class="c5">new</span><span class="c1">&nbsp;LotteryTask(), </span><span class="c4">10000</span><span class="c1">);<br>});<br>createBlockThread.start();</span></p></td></tr></tbody></table><p class="c2"><span class="c7"></span></p><p class="c6"><span>Vervolgens wordt er elke 5 minuten door elke node die aan staat een nieuw block gegenereerd. Elke node doet dit op precies dezelfde tijd omdat de node in het begin zijn tijd gesynct heeft met het netwerk. Bij het maken van het block worden alle pending transactions en de previous block hash in het nieuwe block gezet. Daarnaast zet de huidige wallet zichzelf als validator in het block. Vervolgens voegt hij zijn eigen gemaakte block toe in zijn lijst met proposedBlocks in de temporary storage singleton. </span><span class="c22">Daarna wordt er 1 minuut </span><span class="c7">gewacht tot dat de daadwerkelijke proof of stake loterij wordt afgetrapt. Deze tijd heeft de node nodig om al de overige proposed blocks te ontvangen. </span></p><p class="c2"><span class="c7"></span></p><h2 class="c0" id="h.pa9w5aebxl2g"><span class="c8">4. Ontvangen van proposed blocks andere nodes</span></h2><a id="t.7b85ee61f6924263676b578154205f7a3502a2d9"></a><a id="t.3"></a><table class="c17"><tbody><tr class="c9"><td class="c19" colspan="1" rowspan="1"><p class="c12"><span class="c1">TemporaryStorage.getInstance().addProposedBlock((Block) message.getContent());<br>System.out.println(</span><span class="c3">&quot;[INFO] Received new block&quot;</span><span class="c1">);<br></span><span class="c5">if</span><span class="c1">(handler.shouldSendMessage(message)) {<br> &nbsp; handler.forwardToPeers(message);<br>}</span></p></td></tr></tbody></table><p class="c2"><span class="c7"></span></p><p class="c6"><span class="c7">Alle andere proposed blocks worden ontvangen door alle nodes en in hun eigen temporary storage singleton gezet. </span></p><p class="c2"><span class="c7"></span></p><h2 class="c0" id="h.slz6xj465jgc"><span class="c8">5. Begin van loterij aftrappen</span></h2><a id="t.ed0a53c292fa3f173e93f7700f47b35f8e8e3115"></a><a id="t.4"></a><table class="c17"><tbody><tr class="c9"><td class="c19" colspan="1" rowspan="1"><p class="c12"><span class="c1">String previousHash = GlobalState.getInstance().getLastBlockHash();<br>Block chosenBlock = LotteryUtil.pickWinner(TemporaryStorage.getInstance().getProposedBlocks(), previousHash);<br><br>HashMap&lt;String, Transaction&gt; notValidatedCoinTransactions = </span><span class="c5">new</span><span class="c1">&nbsp;HashMap&lt;&gt;();<br>HashMap&lt;String, Transaction&gt; notValidatedStakeTransactions = </span><span class="c5">new</span><span class="c1">&nbsp;HashMap&lt;&gt;();<br><br></span><span class="c5">for</span><span class="c1">(Block block : TemporaryStorage.getInstance().getProposedBlocks()){<br> &nbsp; </span><span class="c5">if</span><span class="c1">(block.getAllTransactions().size() &gt; chosenBlock.getAllTransactions().size()){<br> &nbsp; &nbsp; &nbsp; notValidatedCoinTransactions = (HashMap&lt;String, Transaction&gt;) block.getCoinTransactions();<br> &nbsp; &nbsp; &nbsp; notValidatedStakeTransactions = (HashMap&lt;String, Transaction&gt;) block.getStakeTransactions();<br> &nbsp; &nbsp; &nbsp;</span><span class="c5">for</span><span class="c1">(Map.Entry&lt;String, Transaction&gt; transactionSet : chosenBlock.getAllTransactions().entrySet()){<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;notValidatedCoinTransactions.remove(transactionSet.getKey());<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;notValidatedStakeTransactions.remove(transactionSet.getKey());<br> &nbsp; &nbsp; &nbsp;}<br> &nbsp; }<br>}<br><br>TemporaryStorage.getInstance().clearProposedBlocks();<br><br>TemporaryStorage.getInstance().addPendingCoinTransactions(notValidatedCoinTransactions);<br>TemporaryStorage.getInstance().addPendingStakeTransactions(notValidatedStakeTransactions);<br><br>GlobalState.getInstance().addBlock(chosenBlock);<br></span><span class="c5">for</span><span class="c1">(Map.Entry&lt;String, Transaction&gt; coinTransactionKeyValueSet : chosenBlock.getCoinTransactions().entrySet()){<br> &nbsp; Transaction coinTransaction = coinTransactionKeyValueSet.getValue();<br> &nbsp; GlobalState.getInstance().changeBalance(coinTransaction.getReceiver(), coinTransaction.getAmount(), BalanceChanger.ADD, TransactionType.COIN);<br> &nbsp; GlobalState.getInstance().changeBalance(coinTransaction.getSender(), coinTransaction.getAmount(), BalanceChanger.SUBTRACT, TransactionType.COIN);<br>}<br></span><span class="c5">for</span><span class="c1">(Map.Entry&lt;String, Transaction&gt; stakeTransactionKeyValueSet : chosenBlock.getStakeTransactions().entrySet()){<br> &nbsp; Transaction stakeTransaction = stakeTransactionKeyValueSet.getValue();<br> &nbsp; GlobalState.getInstance().changeBalance(stakeTransaction.getReceiver(), stakeTransaction.getAmount(), BalanceChanger.ADD, TransactionType.STAKE);<br>}</span></p></td></tr></tbody></table><p class="c2"><span class="c7"></span></p><p class="c6"><span class="c7">Er wordt door elke node een block uitgekozen in de loterij (LotteryUtil.PickWinner). Als het gekozen block eruit is gekomen wordt er gekeken of er nog transactions zijn die nog niet in het gekozen block zitten. Deze worden weer in de pending transactions terug gezet. Vervolgens wordt de global state bijgewerkt met de account balances. </span></p><h2 class="c0" id="h.phn122oyn50"><span class="c8">6. Loterij task</span></h2><a id="t.e4b4b64d897147d29e3d2e3f6c351dd8fb1cbc3e"></a><a id="t.5"></a><table class="c17"><tbody><tr class="c9"><td class="c19" colspan="1" rowspan="1"><p class="c12"><span class="c5">public</span><span class="c1">&nbsp;</span><span class="c5">static</span><span class="c1">&nbsp;Block </span><span class="c11">pickWinner</span><span class="c1">(List&lt;Block&gt; receivedBlocks, String previousBlockId){<br> &nbsp; HashMap&lt;String, Long&gt; stakeHashMap = </span><span class="c5">new</span><span class="c1">&nbsp;HashMap&lt;&gt;();<br> &nbsp; </span><span class="c5">for</span><span class="c1">(GlobalStateUser globalStateUser : GlobalState.getInstance().getUsers()){<br> &nbsp; &nbsp; &nbsp; stakeHashMap.put(globalStateUser.getPublicKey(), globalStateUser.getStake());<br> &nbsp; }<br> &nbsp; HashMap&lt;String, Long&gt; candidatesHashMap = </span><span class="c5">new</span><span class="c1">&nbsp;HashMap&lt;&gt;();<br> &nbsp; HashMap&lt;String, Block&gt; candidateBlocksHashMap = </span><span class="c5">new</span><span class="c1">&nbsp;HashMap&lt;&gt;();<br><br> &nbsp; Long tickets = </span><span class="c4">0l</span><span class="c1">;<br><br> &nbsp; </span><span class="c5">for</span><span class="c1">(Block block : receivedBlocks) {<br> &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">(stakeHashMap.containsKey(block.getValidator())) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tickets += stakeHashMap.get(block.getValidator());<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; candidatesHashMap.put(block.getValidator(), stakeHashMap.get(block.getValidator()));<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; candidateBlocksHashMap.put(block.getValidator(), block);<br> &nbsp; &nbsp; &nbsp; }<br> &nbsp; }<br><br> &nbsp; TreeMap&lt;String, Long&gt; candidatesSortedMap = </span><span class="c5">new</span><span class="c1">&nbsp;TreeMap&lt;&gt;(candidatesHashMap);<br><br> &nbsp; Random random = </span><span class="c5">new</span><span class="c1">&nbsp;Random();<br><br> &nbsp; StringBuilder hashToLong = </span><span class="c5">new</span><span class="c1">&nbsp;StringBuilder();<br><br> &nbsp; </span><span class="c5">for</span><span class="c1">(</span><span class="c5">char</span><span class="c1">&nbsp;c : previousBlockId.substring(</span><span class="c4">0</span><span class="c1">, </span><span class="c4">7</span><span class="c1">).toCharArray()){<br> &nbsp; &nbsp; &nbsp; hashToLong.append(String.valueOf((</span><span class="c5">int</span><span class="c1">) c));<br> &nbsp; }<br><br> &nbsp; random.setSeed(Long.parseLong(hashToLong.toString()));<br> &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;randomNumber = random.nextInt(tickets.intValue()) + </span><span class="c4">1</span><span class="c1">;<br><br> &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;bottomMargin = </span><span class="c4">0</span><span class="c1">;<br> &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;upperMargin = </span><span class="c4">0</span><span class="c1">;<br> &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;candidatePointer = </span><span class="c4">0</span><span class="c1">;<br> &nbsp; </span><span class="c5">while</span><span class="c1">&nbsp;(upperMargin &lt; randomNumber) {<br> &nbsp; &nbsp; &nbsp; String publicKey = </span><span class="c5">new</span><span class="c1">&nbsp;ArrayList&lt;&gt;(candidatesSortedMap.keySet()).get(candidatePointer);<br> &nbsp; &nbsp; &nbsp; Long stake = candidatesSortedMap.get(publicKey);<br> &nbsp; &nbsp; &nbsp; upperMargin += stake;<br> &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(bottomMargin &lt;= randomNumber &amp;&amp; upperMargin &gt;= randomNumber) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;candidateBlocksHashMap.get(publicKey);<br> &nbsp; &nbsp; &nbsp; }<br> &nbsp; &nbsp; &nbsp; bottomMargin += stake;<br> &nbsp; &nbsp; &nbsp; ++candidatePointer;<br> &nbsp; }<br><br> &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;</span><span class="c5">new</span><span class="c1">&nbsp;Block();<br>}</span></p></td></tr></tbody></table><p class="c2"><span class="c7"></span></p><p class="c6"><span>Als aller eerste wordt er een stake hashmap gemaakt die bijhoudt hoeveel stake welke gebruiker / wallet heeft die een block heeft gestuurd. Vervolgens wordt er berekend hoeveel tickets er beschikbaar zijn. Dit wordt gedaan door alle stake de deelnemende nodes bij elkaar op te tellen. Vervolgens wordt er een treemap gemaakt met een gesorteerde kandidaten lijst. Er wordt een random nummer gegenereerd door middel van de previous block hash. Op deze manier is het een random getal maar wel bij elke node in het netwerk hetzelfde. Als laatste wordt er gekeken welke node gewonnen heeft aan de hand van welke tickets hij vast houdt en welk random nummer is gegenereerd (zie while loop). Het gekozen block wordt terug gestuurd en gaat verder bij stap 5.</span></p></body></html>